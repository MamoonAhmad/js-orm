import { Model } from "../../Model";
import { MODEL_ACTIONS } from "../../utils";
import { FIELD_ERRORS, Field } from "../Field";
import {
  ModelFieldGeneralError,
  ModelFieldValidationError,
} from "../ModelFieldValidationError";

class MockedModel extends Model {
  getName(): string {
    return "MockedModel";
  }
  fields() {
    return {
      some: new Field({}),
    };
  }
}

describe("Field", () => {
  describe("constructor", () => {
    it("Sets config correctly", () => {
      expect(new Field({ primaryField: true }).primaryField).toBe(true);
      expect(new Field({}).primaryField).toBe(false);

      expect(new Field({ autoGenerated: true }).autoGenerated).toBe(true);
      expect(new Field({}).autoGenerated).toBe(false);

      expect(new Field({ default: 1 }).default).toBe(1);
      expect(new Field({}).default).toBe(undefined);

      expect(new Field({ description: "someDesc" }).description).toBe(
        "someDesc"
      );
      expect(new Field({}).description).toBe(undefined);

      expect(new Field({ label: "someLabel" }).label).toBe("someLabel");
      expect(new Field({}).label).toBe(undefined);

      expect(new Field({ ioName: "some_io" }).ioName).toBe("some_io");
      expect(new Field({}).ioName).toBe(undefined);

      expect(new Field({ nullable: true }).nullable).toBe(true);
      expect(new Field({}).nullable).toBe(false);

      const parseValue = () => "aaa12";
      expect(new Field({ parseValue }).parseValueOverride).toBe(parseValue);
      expect(new Field({}).parseValueOverride).toBe(undefined);
    });

    it("parses the default value when initiated", () => {
      const parseValue = jest.fn(() => "pp1");
      const field = new Field({ default: 1, parseValue });
      expect(parseValue).toHaveBeenCalledWith(1);
      expect(field.default).toBe("pp1");
    });
  });

  describe("validate", () => {
    it("Should throw error when field is not nullable and value is undefined.", () => {
      expect(() =>
        new Field({ nullable: false }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: undefined,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toThrow(FIELD_ERRORS.NOT_NULLABLE);
    });

    it("Should throw error when field is not nullable and value is null.", () => {
      expect(() =>
        new Field({ nullable: false }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: null,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toThrow(FIELD_ERRORS.NOT_NULLABLE);
    });

    it("Should return a null value when the field is nullable but value passed is undefined or null", () => {
      expect(
        new Field({ nullable: true }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: null,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe(null);

      expect(
        new Field({ nullable: true }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: undefined,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe(null);
    });

    it("Should return validated value when the field is not nullable and value is non truthy.", () => {
      expect(
        new Field({ nullable: true }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: false,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe(false);

      expect(
        new Field({ nullable: true }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: 0,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe(0);
    });
    it("Should return null when non-nullable field has a default value but value provided is null or undefined", () => {
      expect(
        new Field({ nullable: true, default: 1 }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: undefined,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe(null);

      expect(
        new Field({ nullable: true, default: 1 }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: null,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe(null);
    });
    it("Should throw when the field is auto generated and model action is not CREATE and the value provided is null or undefined.", () => {
      expect(() =>
        new Field({ autoGenerated: true, nullable: true }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: undefined,
          modelAction: MODEL_ACTIONS.UPDATE,
        })
      ).toThrow(FIELD_ERRORS.AUTO_GENERATED_NO_NULLABLE_ON_UPDATE);

      expect(() =>
        new Field({ autoGenerated: true, nullable: false }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: null,
          modelAction: MODEL_ACTIONS.UPDATE,
        })
      ).toThrow(FIELD_ERRORS.NOT_NULLABLE);
    });

    it("returns parsed value.", () => {
      const mock = jest.fn(() => "some1");
      expect(
        new Field({
          parseValue: mock,
        }).validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: "passedValue",
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe("some1");
      expect(mock).toHaveBeenCalledWith("passedValue");

      const field = new Field({});
      const parseValueMocked = jest.fn((v) => v);
      field.parseValue = parseValueMocked;
      expect(
        field.validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: "passedValue",
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toBe("passedValue");
      expect(parseValueMocked).toHaveBeenCalled();
      expect(parseValueMocked).toHaveBeenCalledWith("passedValue");
    });

    it("Throws Validation error when the parse value function fails.", () => {
      const field = new Field({});
      const parseValueMocked = jest.fn(() => {
        throw new Error("Nope.");
      });
      field.parseValue = parseValueMocked;
      expect(() =>
        field.validate({
          fieldName: "some",
          name: "some",
          modelInstance: new MockedModel({}),
          value: "passedValue",
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toThrow(new ModelFieldValidationError("Nope.", "some"));
    });
  });

  describe("watchFields", () => {
    it("returns the passed name at least", () => {
      expect(new Field({}).watchFields("some")).toEqual(["some"]);
    });
  });

  describe("setValue", () => {
    it("set the value and return the partial model field object.", () => {
      expect(
        new Field({}).setValue({
          fieldName: "f11",
          name: "some",
          modelInstance: new MockedModel({}),
          value: 1,
        })
      ).toEqual({
        f11: 1,
      });
    });

    it("On setting the value, it should not parse it", () => {
      const parseValue = jest.fn();
      expect(
        new Field({ parseValue }).setValue({
          fieldName: "f11",
          name: "some",
          modelInstance: new MockedModel({}),
          value: 1,
        })
      ).toEqual({
        f11: 1,
      });

      expect(parseValue).not.toHaveBeenCalled();
    });
  });

  describe("parseValue", () => {
    it("should should return value as it is", () => {
      expect(new Field({}).parseValue(1)).toBe(1);
    });

    it("Should call parseValueOverride if provided", () => {
      const parseValue = jest.fn(() => "cc1");
      expect(new Field({ parseValue }).parseValue(1)).toBe("cc1");
      expect(parseValue).toHaveBeenCalledTimes(1);
      expect(parseValue).toHaveBeenCalledWith(1);
    });
  });

  describe("emitValue", () => {
    it("should emit a partial model io object for field", () => {
      expect(
        new Field({}).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: 1,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toEqual({
        some: 1,
      });
    });

    it("Should return null when the field is not set", () => {
      expect(
        new Field({}).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: undefined,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toEqual({
        some: null,
      });

      expect(
        new Field({}).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: null,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toEqual({
        some: null,
      });
    });

    it("should return default value", () => {
      expect(
        new Field({ default: "some1" }).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: undefined,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toEqual({
        some: "some1",
      });
    });

    it("Should utilize ioName when emitting data", () => {
      expect(
        new Field({ ioName: "pp1" }).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: 1,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toEqual({
        pp1: 1,
      });
    });

    it("Value emitted should be parsed.", () => {
      expect(
        new Field({ ioName: "pp1", parseValue: () => "cc1" }).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: 1,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toEqual({
        pp1: "cc1",
      });
    });

    it("Should throw error with field name when parsing fails", () => {
      expect(() =>
        new Field({
          ioName: "pp1",
          parseValue: () => {
            throw new Error("Nope1.");
          },
        }).emitValue({
          modelInstance: new MockedModel({}),
          name: "some",
          value: 1,
          modelAction: MODEL_ACTIONS.CREATE,
        })
      ).toThrow(new ModelFieldGeneralError("Nope1.", "some"));
    });
  });

  describe("processIOObject", () => {
    it("Should return a partial model field object", () => {
      expect(
        new Field({}).fromIOObject({
          name: "some1",
          ioObject: { some1: 10 },
          modelInstance: new MockedModel({}),
        })
      ).toEqual({
        some1: 10,
      });
    });

    it("Should return a partial model field object", () => {
      expect(
        new Field({ ioName: "p11" }).fromIOObject({
          name: "some1",
          ioObject: { p11: 10, some1: "some" },
          modelInstance: new MockedModel({}),
        })
      ).toEqual({
        some1: 10,
      });
    });

    it("Should return a partial model field object", () => {
      const parseValue = jest.fn(() => "pp1");
      expect(
        new Field({ parseValue }).fromIOObject({
          name: "some1",
          ioObject: { some1: "some" },
          modelInstance: new MockedModel({}),
        })
      ).toEqual({
        some1: "pp1",
      });
      expect(parseValue).toHaveBeenCalledWith("some");
    });

    it("Should error out when initialized with null and the field is non-nullable", () => {
      expect(() =>
        new Field({ nullable: false }).fromIOObject({
          ioObject: {},
          modelInstance: new MockedModel({}),
          name: "some",
        })
      ).toThrow("Received a null value for non-nullable field.");
    });
  });
});
